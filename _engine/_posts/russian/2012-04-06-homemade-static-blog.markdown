---
layout: post
language: russian
date: 2012-04-06 22:16
title: Самодельный статический движок для блога Goblog
draft: yes
---
Я люблю писать тексты, люблю отлаживать примеры, пробовать, анализировать. Чего я не люблю, так это возиться с форматированием, закачиванием картинок, проверкой верстки и т.д.

По причине лени я начал использовать Блогспот. Тут тебе и море шаблонов, виджеты всякие, мгновенная индексация Гуглом, статистика разная, с какого-то времени даже комментарии стали древовидные, и прочие свистелки. Ну все бы хорошо, но, увы, не предназначен редактор Блогспота для создания программистских постов. Когда надо вставлять код или таблицы разные, начинаются мучения. Например, для своего другого блога, не про программирование, "[Яйца всмятку, сэр!][]" "возможностей" Блогспота вполне хватает.

[Яйца всмятку, сэр!]: http://english-eggs.blogspot.com

Еще мне хочется хранить оригиналы постов в нормальном, не в обгаженном HTML'ем виде. Получалось, что материалы по блогу раскиданы по компьютеру там и сям в нескольких копиях. Сначала ты просто пишешь текст в редакторе, только разбивая на абзацы, без ссылок и картинок, и в конце сохраняешь почти готовый документ. Потом начинается ~~ëрзанье~~верстка в HTML, в процессе которой, помимо, собственно, HTML'я, делаются поправки в оригинальном тексте. При этом обновлять оригинальный файл уже лень, и по сути, он остается в "сыром" виде. А в "сухом" виде остается только HTML'ная помойка. Но это еще не конец истории. Часто уже после публикации замечаешь опечатку, лезешь в Блогспот правишь прямо на странице. Опять, самый первый оригинал и его локальная об'HTML'ная версия остаются неисправленными. В итоге: актуальные версии постов находятся только на самом Блогспоте. Конечно, можно делать автоматизированный бэкап всего блога, но опять таки - все будет уже только в HTML'е.

Некоторое время назад я начал использовать [ReST][]. Тут жизнь хоть как-то полегчала. ReST позволяет писать текст в уже более менее предсказуемой разметке (абзацы, ссылки, код), и затем из него генерируется HTML, который вставляется (опять таки вручную) в Блогспот. Попытки автоматизировать предварительный просмотр поста через [googlecl][] фактически провалились. Опять оставалась проблема, когда после исправления опечатки на странице оригинальный документ в ReST устаревал. Кроме того, ReST не решал проблему картинок. Их надо было куда-то заранее выкладывать, чтобы можно было полностью сделать preview.

[ReST]: http://docutils.sourceforge.net/rst.html
[googlecl]: http://code.google.com/p/googlecl/

Не могу объяснить почему, но идея динамических движков типа Wordpress'а меня как-то пугала. Сама идея держать посты в базе данных мне кажется перебором.

Я почти уже было остановился на промежуточном решении -- [Doku Wiki][], например как на [vak.ru][]. Тут движок хоть и динамический, но содержимое страниц хранится в файлах, и есть версионность. Doku можно использовать как движок всего сайта, не только блога. Хоть и дизайн неказистый, зато картинки и произвольные аттачменты поддерживаются системой. 

[Doku Wiki]: http://www.dokuwiki.org/dokuwiki
[vak.ru]: http://vak.ru/doku.php/proj

Был еще вариант, на который я тоже почти подписался - блог на основе [TiddlyWiki][]. TiddlyWiki - это мой любимый инструмент на Windows для ведения записей. Я про это уже [писал][Электронная записная книга TiddlyWiki]. Почему на Windows? Потому что на Маке я просто делаю записи в простых текстовых файлах, располагая их по смыслу в документах или на рабочем столе, а [Spotlight][], который индексирует все и вся на компьютере, моментально позволяет искать по фрагментам слов. Получается, что в ключевых возможностях TiddlyWiki, мгновенном поиске, уже не особого смысла. Но я отвлекся.

[Электронная записная книга TiddlyWiki]: /blog/russian/2009/11/28/tiddly-wiki/
[Spotlight]: http://en.wikipedia.org/wiki/Spotlight_(software)

Оказывается, есть фанаты, которые превратили TiddlyWiki в блог-платформу. В эдакий статико-динамический мутант.

Например, вариант блога с таким движком - [Rich Signell's Work Log][]. Эзотерика, на мой взгляд. Например, не ясно, как прикрутить комментарии, хотя бы то же Disqus. Но если кому интересно, есть даже публичный хостинг - tiddlyspot.

[Rich Signell's Work Log]: http://rsignell.tiddlyspot.com/
[tiddlyspot]: http://tiddlyspot.com/

И вот реально я возбудился на идее чисто статических движков. Прелесть тут в том, что такой блог хостить можно где угодно. Тут не только база данных не нужна, и даже серверное скриптование. Но дальше - больше. GitHub или Heroku позволяют не только хостить статические сайты, но и управлять контентом через git. 

Например, есть статический движок [Jekyll][]. В Jekyll посты пишутся с использованием разметки Markdown или Textile. Также можно добавлять в проект произвольные файлы, которые при генерации сайта будут выкладываться без изменений. По сути - это движок сайта, в котором еще можно некоторые файлы оформлять в виде блога.

Комментарии же, как основная "динамика" блога, может реализоваться через, например, [Disqus][]. К слову сказать, есть эстэты статических блогов с высшей степенью дзэна - со *статическими комментариями* (для меня даже это словосочетания является оксюмороном). Подход тут такой: у поста внизу есть секция со *статически* выведенными ранее введенными комментариями, и рядом форма для ввода нового. Ты вводишь комментарий, и он отсылается автору блога. Тот его подтверждает (или нет), куда-то кликает, и комментарий помещается в виде файла в статический проект блога, все пересобирается и выкладывается на публику. Понятно, что это никакой ни разу не real-time, а больше похоже на комментарии с пре-модерированием, причем модератор выходит на связь раз в неделю.

[Disqus]: http://disqus.com

Я очень ценю дискуссию, и подобный подход не для меня. И продолжаю использовать Disqus.

Кстати, из Disqus можно прекрасно экспортировать базу комментарием, и, например, превратить ее в статические страницы, если вдруг придется в него уходить.

Но вернемся к Jekyll.

Например, GitHub Pages напрямую поддерживает Jekyll (его автор и есть сооснователь GitHub) и умеет рендерить Jekyll (хотя можно и рендерить самому локально). Заливаешь через git проект Jekyll, и сайт становится видимым в GitHub Pages.

На Heroku идея немного иная. Heroku хостит Ruby, поэтому статический сайт на Heroku - это сами страницы и программа-вебсервер, которая их отдает. Звучит страшновато, но на Ruby такой сервер выглядит весьма компактно, например так:

{% codeblock lang:ruby %}
require 'bundler/setup'
require 'sinatra/base'

class SinatraStaticServer < Sinatra::Base  

  get(/.+/) do
    send_sinatra_file(request.path) {404}
  end

  def send_sinatra_file(path, &missing_file_block)
    file_path = File.join(File.dirname(__FILE__), 'public',  path)
    file_path = File.join(file_path, 'index.html') unless file_path =~ /\.[a-z]+$/i  
    File.exist?(file_path) ? send_file(file_path) : missing_file_block.call
  end
end

run SinatraStaticServer
{% endcodeblock %}

[Jekyll]: http://jekyllrb.com/

Как ни странно, хостинг на Heroku в целом проще, чем на GitHub. Также на Heroku git-репозиторий блога остается private, тогда как на GitHub'е он становиться открытым как и все остальные проекты. Хотя для меня звучит странно держать проект блога (фактически, сайта) закрытым. Он же и так весь допупен через веб.

Да, и GitHub Pages и Heroku позволяются "прикрутить" нормальный домен второго уровня, если у вас есть таковой.

Итак, я выбрал Jekyll c хостингом на Heroku. Увы, если взять чистый Jekyll, то придется самому с нуля разрабатывать стили и макет страниц. Если этим заниматься лень, то можно взять [Octopress][].

[Octopress]: http://octopress.org/

Octopress - это статический движок блога на базе Jekyll, но который укомплектован HTML5 макетом страниц, пачкой удобных плагинов и автоматизированной возможностью выкладывания блога на GitHub Pages и Heroku.

Итак, я взял Octopress, покрутил туда-сюда, попробовал несколько постов, протестировал рендерить блог локально, повыкладывал на Heroku и GitHub Pages. Все вроде было на мази.

Далее была самая нудная часть марлезонского балета - перетаскивание постов из любимого Блогспота. Фактически приходилось это делать вручную через cut-and-paste. Недели три мучений, и свои несчастные триста постов я обработал.

Все было готово для запуска моего нового статического блога. Но тут меня ждало главное разочарование.

Драгоценный Jekyll, написанный на Ruby, рендерил мои несчастные триста постов (внимание!) - 15 минут (на Mac Air). А как сами понимаете, надо было много пробовать, пересобирать, особенно сначала. И такое время полной пересборки не лезло ни в какие ворота.

Методом тыка а нашел узкое место в движке Jekyll/Octopress - львиная доля этих 15 минут уходил на генерацию файла atom.xml, RSS-фида. Почему-то в изначальных шаблонах в этот RSS-файл включалось только последние двадцать постов. Но у меня блог небольшой, поэтому я включил туда все посты, и тогда время генерации этого файла приводилось к пятнадцати минутной сброки всего блога.

Все это показалось мне каким-то абсурдом (при всей моей любви к Ruby). После небольшого размышления (я к тому времени уже более менее понимал внутренности Jekyll), я задался вопросом - а не написать ли мне свой статический движок по схожей идее? Ведь это всего навсего работа с файлами, текстом и, возможно, шаблонами.

На чем писать? Можно по-мужски: на C++/boost, но скучно. Я решил на Go. Нативная, очень быстрая компиляция, удобная работа со строками и файловой системой, урощенная работа с памятью (сборщик мусора), регулярные выражения, библиотека шаблонов, [библиотека для Markdown][]. Все, кроме последнего, "из коробки". Каких-либо проблем с производительностью не должно быть вообще.

[библиотека для Markdown]: https://github.com/russross/blackfriday

Итак, после трех вечеров родился мой велосипед - Goblog. Весь проект [открытый][Проект demin.ws]. Сайт и его исходные тексты находятся вместе.

[Проект demin.ws]: https://github.com/begoon/begoon.github.com

# Принцип работы

Есть два основых места: проект и собранный сайт-блог. В первом лежат исходные файлы. В процесс сборки файлы из проекта копируется в собранный сайт с сохранением локальной структуры каталогов. По умолчанию файлы копируются без изменений, как двоичные. Если же какой-то файл имеет расширение `html`, `xml` или `js`, то этот файл прогоняется через [систему шаблонов Go][Templates in Go]. Файлы с расширением `markdown` дополнительно перед шаблонами обрабатываются [библиотекой Markdown][библиотека для Markdown].

[Templates in Go]: http://weekly.golang.org/pkg/text/template/

Каталоги:

* `[корень][]` - здесь находится собранный сайт, как он видится по адресу [demin.ws/][root]
* `[_engine][]` - это проект, тут лежает исходники и генератор сайта. Технически, этот каталог виден через web.

[корень]: https://github.com/begoon/begoon.github.com
[_engine]: https://github.com/begoon/begoon.github.com/tree/master/_engine/

Подкаталоги и файлы в каталоге `_engine`:

* 

# Подсветка синтаксиса

В качестве расширения Markdown у меня есть специальный тег для вставки блоков кода:

    {\# codeblock lang:xxx %}
    ...
    {\# endcodeblock %}
    
Я унаследовал этот тег из Octopuss'a. Стандартный Markdown уже имеет синтаксис для кода:

    ``` xxx
    ...
    ```

где `xxx` - язык.

Но свой тег позволяет мне проще добавлять атрибуты, например, включение отображения номеров строк, преобразование табуляций и т.д.

Далее надо было решить вопрос подсветки синтаксиса. Я покрутил несколько онлайновых библиотек, которые через JavaScript раскрышивает прямо на странице, но в каждой была какая-то минимальная проблема, поэтому я таки решил раскрашивать код статически.

Первое, что пришло в голову - [pygments][]. Все бы хорошо, но благодаря Питону, работает крайне медленно. Время полной сборки сайта с 15 секунд выросло до двух минут. Основное время тратилось на раскраску кода. Приходили мысли на тему кеша уже раскрашенных фрагментов и прочей ерунде, но после небольшого поиска проблема решилась радикально.

[pygments]: http://pygments.org/

Надо было просто взять колоризатор, написанный на правильном для данной задачи языке. Отыскались две альтернативы: [GNU Source-highlight][] и [Highlight][]. Оба написаны на C++, поэтому работают практически мгновенно. 

Например, вот тут [человек сравнивал производительность pygments и syntax-highlight][Adding Color to the Console: Pygments vs. Source-highlight].

Мне больше понравился Highlight. В нем языков больше поддерживается (например, в GNU'шном даже Go нет). После перехода на Highlight время полной сборки вернулось к ~15-20 секундам, и я удовлетворился.

Вызов колоризатора сделан через обратный вызов в регулярном выражении, которое обрабатывает тег `{\% codeblock %}` (функция [highlight()][main.go]).

# Локальное тестирование

Чтобы запустить сайт локально, я временно добавляю `127.0.0.1 demin.ws` в `/etc/hosts` и запускаю мини web-сервер. Помните как он выглядел на Ruby? Маленький, правда? А теперь версия на Go ([server.go][]):

{% codeblock lang:go %}
package main
import "net/http"
func main() {
  panic(http.ListenAndServe(":80", http.FileServer(http.Dir(".."))))
}
{% endcodeblock %}

[server.go]: https://github.com/begoon/begoon.github.com/blob/master/_engine/server.go

Итак:

    go run server.go&

И можно тестировать сайт локально (возможно придется запустить через `sudo`, чтобы "сесть" на 80-й порт).

В принципе, можно и не трогать `/etc/hosts` и использовать адрес `localhost:80`, но RSS-фид файл `atom.xml` содержит абсолютные ссылки c доменом, поэтому для если надо тестировать RSS, то без подмены адреса не обойтись.

# Структура проекта

Есть несколько специальных каталогов:

* `_posts` - тут лежает посты. Посты - это Markdown-файлы, имеющие особый заголовок и имя. Данные файлы обрабатывается особо, и выкладываются в отдельный каталог `/blog` с подкаталогами-датами. Информация о постах собирается в специальные переменные, которые делаются видимыми из шаблонов. Также постам строится обратный индекс для поиска.




# Теги (категории)

Я решил не делать теги вообще. Основываясь на собственном опыте, я понял, что никогда не пользуюсь тегами ни в своем блоге, ни в чужих. К тому же со временем взгляды на логику категоризации информации меняются, и порой приходится просто для совместимости с прошлым расставлять теги, в которых уже не видишь смысла. Какой, например, смысл в теге `c++` в моем блоге? Кто-нибудь когда-нибудь его использовал?

Но минимализм - это не путь к усложнению жизни. Наоборот. Лично я постоянно что-то ищу у себя в блоге в старых постах. На Блогспоте я просто заходил на главную страницу, жал `&amp;#8984;-F` (ой, простите, CTRL-F) и искал про фрагментам слов в заголовках. Именно для этого я с некоторого в правой колонке стал выводить ссылки практически на все информативные посты.

В новом блоге все "работает" точно также прямо на первой странице с каталогом постов. При переносе постов я изменил заголовки некоторых, сделав их более информативными и пригодными для поиска.

Но! Все это уже не важно, так как теперь в блоге [работает полнофункциональный контекстный поиск][В блоге работает поиск].

[В блоге работает поиск]: /blog/russian/2012/04/10/search-in-this-blog/

# Два языка

Была еще проблема, которую, как мне кажется, удалось решить весьма элегантно: двуязычность. Мне нужен блог и сайт на двух языках. Но хардкодить "прозрачную" поддержку русского и английского как-то не хотелось, к тому же версии на разных языках могу радиально отличаться. В итоге, у меня есть просто понятие языка у каждого обрабатываемого файла, заданное в заголовке каждого файла. Goblog не знает о языках. Он просто делает информацию о языке файла или поста доступной через шаблоны. А я уж сам решаю, где лежат какие файлы. Например, все русское лежит, начиная с корня сайта, а все английское имеет префикс `/english`.

Например, [русская титульная страница][] 

[русская титульная страница]: https://github.com/begoon/begoon.github.com/blob/master/_engine/_site/index.html
https://github.com/begoon/begoon.github.com/blob/master/_engine/_site/english/index.html


Минус - придется ра

# Мораль 

Вы думаете, я сейчас буду убеждать использовать мой движок? Совсем нет. Хоть я старался сделать движок максимально гибким и непривязанным конкретно к моему блогу, но так как мне пришлось переносить старые посты, поддержать два языка и т.д., в коде из куски, "заточенные" конкретно под мой блог.

Все только могу порекомендовать, что статический движок персонального сайта/блога стоит написать самому. Почему? А потому, что эта задача решается за несколько вечеров (раз), и в нем будет только то, что вам реально нужно (остальное вам будет лень программировать) (два).


P.S. Этот писался почти неделю, урывками. Параллельно я писал поиск. Внезапно я осознал, как все-таки это нереально удобно с git'ом в работе с блогом. Пишешь в бэкграунде пост - ветка, дописываешь функционал (например, поиск был создан в процессе написания этого поста) - ветка. Когда что-то готово, сливает в master и push на GitHub. Красота.


Ссылки по теме:

* [GNU Source-highlight][]
* [Highlight][]
* [Adding Color to the Console: Pygments vs. Source-highlight][]

[GNU Source-highlight]: http://www.gnu.org/software/src-highlite/
[Highlight]: http://www.andre-simon.de/doku/highlight/en/highlight.html
[Adding Color to the Console: Pygments vs. Source-highlight]: http://petereisentraut.blogspot.co.uk/2009/07/adding-color-to-console-pygments-vs.html

[main.go]: https://github.com/begoon/begoon.github.com/blob/master/_engine/main.go
