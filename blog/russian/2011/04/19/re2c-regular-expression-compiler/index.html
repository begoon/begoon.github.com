<!DOCTYPE html>
 
<html>
<head>
   <meta http-equiv="content-type" content="text/html; charset=utf-8" />
   <title>re2c - компилятор регулярных выражений</title>
   <link href="/favicon.png" rel="icon">
   <script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-3017739-19']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

   <link rel="stylesheet" href="/css/screen.css" type="text/css" media="screen, projection" />
   <link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet">
   <link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet"> 
</head>
<body>

<div class="site">

  <div class="menu">
    <a class="extra" href="/english">&laquo; english &raquo;</a>  
    <a href="/">блог</a> |
    <a href="/projects/">проекты</a> |
    <a href="/articles/">статьи</a> |
    <a href="/about/">автор</a>
  </div>

  <div id="home">
    <h1>re2c - компилятор регулярных выражений</h1>
<div id="post">
  <p>Задача выделения из потока символов определенных лексем является весьма распространенной. Часто ее решают с помощью лексических анализаторов, конфигурируемых регулярными выражениями. Многие анализаторы построены по принципу генерации программного кода, который в свою очередь реализует логику регулярных выражений. Фактически, это компиляция языка регулярных выражений в код языка программирования.</p>

<p>Например, <a href="http://en.wikipedia.org/wiki/Flex_lexical_analyser">flex</a> - это один из таких анализаторов. Старый, но проверенный годами.</p>

<p>Я много пользовался flex&rsquo;ом, он имеет и плохие и хорошие стороны, но по большому счету, жаловаться не приходилось.</p>

<p>Но вчера наткнулся на интересный проект - <a href="http://re2c.org/">re2c</a>. По сути, на этой штуке можно писать лексические анализаторы прямо на коленке за несколько минут.</p>

<p>Сразу рассмотрим пример.</p>

<p>Допустим, вам нужно из строки выделять некоторые команды, целые и дробные числа. Можно расчехлить flex, а можно написать так:</p>

<pre><code class="cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

enum {
  CMD, INT, FLOAT, SPACE, END
};

int scan(char** p, char** lex)
{
    char* marker;
    if (lex) *lex = *p;
/*!re2c
        re2c:define:YYCTYPE  = &quot;unsigned char&quot;;
        re2c:define:YYCURSOR = *p;
        re2c:define:YYMARKER = marker;
        re2c:yyfill:enable   = 0;
        re2c:yych:conversion = 1;
        re2c:indent:top      = 1;
        &quot;GET&quot;|&quot;PUT&quot;|&quot;EXIT&quot; { return CMD; }
        [0-9]+             { return INT; }
        [0-9]+ '.' [0-9]*  { return FLOAT; }
        [ \t]+             { return SPACE; }
        [^]                { return END; }
*/
}

int main(int argc, char* argv[]) {
  char *p, *last;
  int token;
  if (argc &lt; 2) return 1;

  p = argv[1];
  while ((token = scan(&amp;p, &amp;last)) != END) {
    int sz = p - last;
    switch (token) {
      case CMD: printf(&quot;Command: '%.*s'\n&quot;, sz, last); break;
      case INT: printf(&quot;Number: '%.*s'\n&quot;, sz, last); break;
      case FLOAT: printf(&quot;Float: '%.*s'\n&quot;, sz, last); break;
    }
  }

  return 0;
}
</code></pre>

<p>И все!</p>

<p>Понятно, что вся магия происходит в функции <code>scan()</code> между строками, ограниченных комментариями <code>/*!re2c</code> и <code>*/</code>.</p>

<p>Итак, re2c - это компилятор регулярных выражений, который встраивает код прямо в текст программы.</p>

<p>Если прогнать наш исходник через re2c:</p>

<pre><code>re2c.exe -is test.re2c &gt;test.c
</code></pre>

<p>То получим вот такое:</p>

<pre><code class="cpp">/* Generated by re2c 0.13.5 on Tue Apr 19 21:08:57 2011 */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

enum {
  CMD, INT, FLOAT, SPACE, END
};

int scan(char** p, char** lex)
{
    char* marker;
    if (lex) *lex = *p;

    {
        unsigned char yych;

        yych = (unsigned char)**p;
        if (yych &lt;= '9') {
            if (yych &lt;= 0x1F) {
                if (yych == '\t') goto yy8;
                goto yy10;
            } else {
                if (yych &lt;= ' ') goto yy8;
                if (yych &lt;= '/') goto yy10;
                goto yy6;
            }
        } else {
            if (yych &lt;= 'F') {
                if (yych == 'E') goto yy5;
                goto yy10;
            } else {
                if (yych &lt;= 'G') goto yy2;
                if (yych == 'P') goto yy4;
                goto yy10;
            }
        }
yy2:
        yych = (unsigned char)*(marker = ++*p);
        if (yych == 'E') goto yy24;
yy3:
        { return END; }
yy4:
        yych = (unsigned char)*(marker = ++*p);
        if (yych == 'U') goto yy23;
        goto yy3;
yy5:
        yych = (unsigned char)*(marker = ++*p);
        if (yych == 'X') goto yy18;
        goto yy3;
yy6:
        ++*p;
        if ((yych = (unsigned char)**p) == '.') goto yy13;
        if (yych &lt;= '/') goto yy7;
        if (yych &lt;= '9') goto yy16;
yy7:
        { return INT; }
yy8:
        ++*p;
        yych = (unsigned char)**p;
        goto yy12;
yy9:
        { return SPACE; }
yy10:
        yych = (unsigned char)*++*p;
        goto yy3;
yy11:
        ++*p;
        yych = (unsigned char)**p;
yy12:
        if (yych == '\t') goto yy11;
        if (yych == ' ') goto yy11;
        goto yy9;
yy13:
        ++*p;
        yych = (unsigned char)**p;
        if (yych &lt;= '/') goto yy15;
        if (yych &lt;= '9') goto yy13;
yy15:
        { return FLOAT; }
yy16:
        ++*p;
        yych = (unsigned char)**p;
        if (yych == '.') goto yy13;
        if (yych &lt;= '/') goto yy7;
        if (yych &lt;= '9') goto yy16;
        goto yy7;
yy18:
        yych = (unsigned char)*++*p;
        if (yych == 'I') goto yy20;
yy19:
        *p = marker;
        goto yy3;
yy20:
        yych = (unsigned char)*++*p;
        if (yych != 'T') goto yy19;
yy21:
        ++*p;
        { return CMD; }
yy23:
        yych = (unsigned char)*++*p;
        if (yych == 'T') goto yy21;
        goto yy19;
yy24:
        ++*p;
        if ((yych = (unsigned char)**p) == 'T') goto yy21;
        goto yy19;
    }

}

int main(int argc, char* argv[]) {
  char *p, *last;
  int token;
  if (argc &lt; 2) return 1;

  p = argv[1];
  while ((token = scan(&amp;p, &amp;last)) != END) {
    int sz = p - last;
    switch (token) {
      case CMD: printf(&quot;Command: '%.*s'\n&quot;, sz, last); break;
      case INT: printf(&quot;Number: '%.*s'\n&quot;, sz, last); break;
      case FLOAT: printf(&quot;Float: '%.*s'\n&quot;, sz, last); break;
    }
  }

  return 0;
}
</code></pre>

<p>Страшно? Да, код не для ручной правки, но это и не требуется.</p>

<p>Компилируем:</p>

<pre><code>re2c.exe -is test.re2c &gt;test.c &amp;&amp; cl test.c
</code></pre>

<p>Запускаем:</p>

<pre><code>test &quot;GET 123.0 12344 PUT 10.&quot;
</code></pre>

<p>Результат:</p>

<pre><code>Command: 'GET'
Float: '123.0'
Number: '12344'
Command: 'PUT'
Float: '10.'
</code></pre>

<p>Как говориться, быстро, дешево и сердито. Чтобы полностью овладеть re2c надо прочитать одну и единственную <a href="http://re2c.org/manual.html">страничку документации</a>.</p>

<p>Кстати, простота работы с re2c не означает, что на нем нельзя делать сложных анализаторов. В <a href="http://sourceforge.net/projects/re2c/">дистрибутиве</a> есть примеры для грамматики токенов языков C и Rexx.</p>

<p>Если поиграться с <a href="http://re2c.org/manual.html#lbAE">флагами re2c</a>, то можно вместо <code>if/else</code> генерировать код на основе <code>switch/case</code>. Выбор стоит сделать на основе понимания, какой код ваш компилятор лучше оптимизирует.</p>

<p>Как я понимаю, анализатор, сгенерированный re2c должен быть весьма быстр, даже очень быстр. Хотя было бы интересно померить его против того же flex, <a href="http://www.antlr.org/">ANTLR</a> или <a href="http://www.boost.org/doc/libs/1_41_0/libs/spirit/doc/html/spirit/lex/tutorials/lexer_tutorials.html">Spirit</a>.</p>

<p>Посты почти по теме:</p>

<ul>
<li><a href="/blog/russian/2009/07/06/wrapper-for-lemon/">Обертка генератора парсеров грамматик Lemon для C++</a></li>
</ul>

</div>

<hr />


  <a href="http://easy-coding.blogspot.com/2011/04/re2c.html"><small>Оригинальный пост</small></a>


<h1>Комментарии</h1>

<div id="disqus_thread"></div>

<script type="text/javascript">
  var disqus_shortname = 'easy-coding';
  var disqus_developer = 0;
  var disqus_identifier = 'http://easy-coding.blogspot.com/2011/04/re2c.html';
  var disqus_url = 'http://easy-coding.blogspot.com/2011/04/re2c.html';
  var disqus_script = 'embed.js';
  (function () {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  }());
</script>


  </div>

  <div class="footer">
    <div class="contact">
      &copy; 2012
      <a href="mailto:alexander@demin.ws">Александр Дëмин</a> |
      <a href="/atom.xml" rel="subscribe-rss" title="Подписаться через RSS">RSS</a>
    </div>
  </div>

</div>



</body>
</html>
