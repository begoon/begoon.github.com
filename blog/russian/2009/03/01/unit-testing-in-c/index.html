<!DOCTYPE html>
 
<html>
<head>
   <meta http-equiv="content-type" content="text/html; charset=utf-8" />
   <title>Unit-тестирование в языке С</title>
   <link href="/favicon.png" rel="icon" />
   <script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-3017739-19']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

   <link rel="stylesheet" href="/css/screen.css" type="text/css" media="screen, projection" />
   <link rel="stylesheet" type="text/css" href="/css/highlight.css" />
   <link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" />
   <link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" /> 
   <link rel="alternate" title="Программирование - это просто!" href="/atom.xml" type="application/atom+xml">
</head>
<body>

<div class="site">

  <div class="menu">
    <a class="extra" href="/english">&laquo; english &raquo;</a>  
    <a href="/">блог</a> |
    <a href="/projects/">проекты</a> |
    <a href="/articles/">статьи</a> |
    <a href="/about/">автор</a>
  </div>

  <div id="home">
    <h1>Unit-тестирование в языке С</h1>
<div id="post">
  <p>По роду работы мне приходится работать с огромным количеством кода на С, причем чаще всего — это старый код, написанный много лет назад, и написан он без каких-либо намеков на тестирование, увы.
Исправляя в таком коде ошибки, внося какие-то изменения, хочется какой-то гармонии с самим собой, а именно — иметь возможность тестировать, тем самым уменьшить вероятность повторного внесения ошибок. Пусть уж полностью старый код остается без тестов, но раз уж я что-то меняю, я хочу подкрепить свои изменения тестами.</p>

<p>Мир языка С++ не такой дружественный к тестированию, как например, мир Java, C# или мир интерпретаторов. Главная причина — крайне слабый механизм интроспекции, то есть возможности исследования двоичного кода в плане получения информации о структуре исходных текстов. В Java, например, есть <code>Reflection</code>, с помощью которого можно прямо на основе скомпилированных классов создать тестовую среду (понять иерархию классов, типа аргументов и т.д.). В С++ приходится многое закладывать в исходный текст на этапе его создания, чтобы облегчить будущее тестирование.</p>

<p>А что же мы имеем в С? Тут, как мне кажется, разрыв в удобстве тестирования по отношению к С++ в разы больше, чем между С++ и Java, например. Причин море: процедурная модель вместо объектно-ориентированной, отсутствие интроспекции вообще, крайне слабая защита при работе с памятью и т.д.</p>

<p>Но шансы все же остались. Я начал поиск готовых библиотек для unit-тестирования в С. Например, есть библиотека <a href="http://www.jera.com/techinfo/jtns/jtn002.html">MinUnit</a>, длиной в четыре строки. Вполне жизненно. Следующий вполне себе вариант — это <a href="http://cunit.sourceforge.net/">CUnit</a>. Тут даже есть продвинутый консольный интерфейс.</p>

<p>Перебрав еще несколько вариантов, я остановился на гугловской библиотеке <a href="http://code.google.com/p/cmockery/">cmockery</a>. Мне понравилось, что библиотека, несмотря на весьма сложный код, успешно компилируются не только в Visual Studio и GNU C, но и “родными” компиляторами AIX, HP-UX, SunOS и некоторых других экзотических зверей. Также библиотека умеет отлавливать утечки памяти, неправильную работу с распределенными кусками памяти (так называемые buffer over- и under- run). Еще в <code>cmockery</code> есть зачатки mock-механизмов, то есть когда задаются предполагаемые сценарии выполнения тестируемого блока, и потом результаты тестового прогона сверяются с предполагаемым сценарием. Mock-возможности я не буду пока рассматривать в данной статье. Про это стоит написать отдельно.</p>

<p>На текущий момент актуальной версией <code>cmockery</code> является <a href="http://cmockery.googlecode.com/files/cmockery-0.1.2.tar.gz">0.1.2</a>. Из всего архива реально нужны только два файла: <code>cmockery.c</code> и <code>cmockery.h</code>. Можно, конечно, собрать библиотеку как положено, в двоичном виде, но я предпочитаю работать всегда с исходными текстами, благо компилируется очень быстро (это ж не С++).</p>

<p>Желающие, могут скачать <a href="/downloads/cmockery-0.1.2-vs.zip">мою сборку</a>  cmockery. В этом архиве только необходимые два файла <code>cmockery.c</code> и <code>cmockery.h</code>. Также в файл <code>cmockery.h</code> я внес небольшое изменение, связанное к тем, что функция <code>IsDebuggerPresent()</code> почему-то явно объявлена в заголовочных файлах только в Visual Studio 2008. Для студии 2003 и 2005 надо вручную объявлять прототип, иначе при линковке вылезает сообщение:</p>

<pre><code>error LNK2019: unresolved external symbol _IsDebuggerPresent referenced in function __run_test
</code></pre>

<p>Я отрапортовал об этом досадном недочете авторам, и пока новый релиз cmockery не вышел, можно пользоваться моей сборкой, которая без предупреждений компилируются в любой студии.</p>

<p>Теперь пример реального использования <code>cmockery</code>.</p>

<p>Я долго выбирал то, на чем можно хоть как-то наглядно продемонстрировать unit-тестирование в С. В итоге я остановился на библиотеке для работы со строками. Эта библиотека реализует так называемые строки с длинной. То есть надо для кода на С дать более менее удобный интерфейс для манипулированию строками, которые хранят внутри себя длину.</p>

<p>Основа библиотеки была написана весьма давно, и много раз переписывалась практически с нуля, но я все еще использую ее в некоторых проектах.</p>

<p>Естественно, я не буду приводить всю библиотеку. Во-первых, она весьма тривиальна и вся ее &ldquo;фишка&rdquo; состоит в удобности работы, нежели в какой-то особо хитрой и заумной реализации. Во-вторых, полный ее исходный текст весьма объемен. Я выбрал небольшой ее фрагмент, но его тестирование позволяет почувствовать дух тестирования в С.</p>

<p>Итак, библиотека <code>cstring</code>. Тут можно создавать в некоторые &ldquo;объекты&rdquo;, реализованные через структуры, которые представляют собой &ldquo;строки&rdquo;. Такая &ldquo;строка&rdquo; может создаваться либо в стеке (автоматическая переменная), либо в куче. Также предоставляется набор разнообразных базовых функций: определение длины, копирование, склейка, интерфейс со строками языка С <code>(char *)</code> и т.д. Как я уже сказал, для демонстрации системы тестирования я оставил только несколько функций.</p>

<p>Заголовочный файл <code>cstring.h</code>:</p>

<pre class="hl">
<span class="hl ppc">#ifndef _CSTRING_H</span>
<span class="hl ppc">#define _CSTRING_H</span>

<span class="hl ppc">#define _decl_string_t(N) \</span>
<span class="hl ppc">struct {                  \</span>
<span class="hl ppc">  int sz;                 \</span>
<span class="hl ppc">  char data[N];           \</span>
<span class="hl ppc">}</span>

<span class="hl kwc">typedef</span> <span class="hl kwd">_decl_string_t</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">)</span> string_t<span class="hl opt">;</span>

<span class="hl com">/**</span>
<span class="hl com"> * Объявление строки в форме автоматической переменной в стеке.</span>
<span class="hl com"> * Длина строки инициализируется нулем.</span>
<span class="hl com"> */</span>
<span class="hl ppc">#define decl_string_t(name, size) _decl_string_t(size) name = { 0 }</span>

<span class="hl com">/**</span>
<span class="hl com"> * Создание новой строки в куче.</span>
<span class="hl com"> */</span>
string_t<span class="hl opt">*</span> <span class="hl kwd">string_new</span><span class="hl opt">(</span><span class="hl kwb">int</span> sz<span class="hl opt">);</span>

<span class="hl com">/* Трюк с дублированием имен функций, начинающихся с символа '_'</span>
<span class="hl com"> * требуется для подавление предупреждений компилятора о преобразовании</span>
<span class="hl com"> * типов.</span>
<span class="hl com"> */</span>

<span class="hl com">/**</span>
<span class="hl com"> * Удаление строки из кучи.</span>
<span class="hl com"> */</span>
<span class="hl ppc">#define string_delete(str) _string_delete((string_t*)str)</span>
<span class="hl kwb">void</span> <span class="hl kwd">_string_delete</span><span class="hl opt">(</span>string_t<span class="hl opt">*</span> str<span class="hl opt">);</span>

<span class="hl com">/** </span>
<span class="hl com"> * Текущая длина строки.</span>
<span class="hl com"> */</span>
<span class="hl ppc">#define string_length(str) _string_length((const string_t*)str)</span>
<span class="hl kwb">int</span> <span class="hl kwd">_string_length</span><span class="hl opt">(</span><span class="hl kwb">const</span> string_t<span class="hl opt">*</span> str<span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * Изменение длины строки.</span>
<span class="hl com"> */</span>
<span class="hl ppc">#define string_resize(str, sz) _string_resize((string_t*)str, sz)</span>
<span class="hl kwb">int</span> <span class="hl kwd">_string_resize</span><span class="hl opt">(</span>string_t<span class="hl opt">*</span> str<span class="hl opt">,</span> <span class="hl kwb">int</span> sz<span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * Копирование строки из строки С, завершающейся нулем.</span>
<span class="hl com"> */</span>
<span class="hl ppc">#define string_from_c_str(dst, src) _string_from_c_str((string_t*)dst, src)</span>
string_t<span class="hl opt">*</span> <span class="hl kwd">_string_from_c_str</span><span class="hl opt">(</span>string_t<span class="hl opt">*</span> dst<span class="hl opt">,</span> <span class="hl kwb">const char</span><span class="hl opt">*</span> src<span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * Добавление символа в строку.</span>
<span class="hl com"> */</span>
<span class="hl ppc">#define string_append_ch(str, ch) _string_append_ch((string_t*)str, ch)</span>
string_t<span class="hl opt">*</span> <span class="hl kwd">_string_append_ch</span><span class="hl opt">(</span>string_t<span class="hl opt">*</span> str<span class="hl opt">,</span> <span class="hl kwb">char</span> ch<span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * Превращение строки в строку С без добавления нуля на конце.</span>
<span class="hl com"> */</span>
<span class="hl ppc">#define string_data(str) str-&gt;data</span>

<span class="hl com">/**</span>
<span class="hl com"> * Превращение строки в строку С с нулем на конце.</span>
<span class="hl com"> */</span>
<span class="hl ppc">#define string_c_str(str) _string_c_str((string_t*)str)</span>
<span class="hl kwb">char</span><span class="hl opt">*</span> <span class="hl kwd">_string_c_str</span><span class="hl opt">(</span>string_t<span class="hl opt">*</span> str<span class="hl opt">);</span>

<span class="hl ppc">#endif</span>
</pre>

<p>Файл <code>cstring.c</code>:</p>

<pre class="hl">
<span class="hl ppc">#include &lt;stdlib.h&gt;</span>

<span class="hl ppc">#include</span> <span class="hl pps">&quot;cstring.h&quot;</span><span class="hl ppc"></span>

<span class="hl com">/**</span>
<span class="hl com"> * Подготовительная площадка для тестирования.</span>
<span class="hl com"> * Если задан макрос UNIT_TESTING, то функции работы с кучей подменяются</span>
<span class="hl com"> * на тестовые.</span>
<span class="hl com"> */</span>
<span class="hl ppc">#if UNIT_TESTING</span>
<span class="hl kwc">extern</span> <span class="hl kwb">void</span><span class="hl opt">*</span> <span class="hl kwd">_test_malloc</span><span class="hl opt">(</span><span class="hl kwb">const size_t</span> size<span class="hl opt">,</span> <span class="hl kwb">const char</span><span class="hl opt">*</span> file<span class="hl opt">,</span> <span class="hl kwb">const int</span> line<span class="hl opt">);</span>
<span class="hl kwc">extern</span> <span class="hl kwb">void</span><span class="hl opt">*</span> <span class="hl kwd">_test_calloc</span><span class="hl opt">(</span><span class="hl kwb">const size_t</span> number_of_elements<span class="hl opt">,</span> <span class="hl kwb">const size_t</span> size<span class="hl opt">,</span>
                          <span class="hl kwb">const char</span><span class="hl opt">*</span> file<span class="hl opt">,</span> <span class="hl kwb">const int</span> line<span class="hl opt">);</span>
<span class="hl kwc">extern</span> <span class="hl kwb">void</span> <span class="hl kwd">_test_free</span><span class="hl opt">(</span><span class="hl kwb">void</span><span class="hl opt">*</span> <span class="hl kwb">const</span> ptr<span class="hl opt">,</span> <span class="hl kwb">const char</span><span class="hl opt">*</span> file<span class="hl opt">,</span> <span class="hl kwb">const int</span> line<span class="hl opt">);</span>

<span class="hl ppc">#define malloc(size) _test_malloc(size, __FILE__, __LINE__)</span>
<span class="hl ppc">#define calloc(num, size) _test_calloc(num, size, __FILE__, __LINE__)</span>
<span class="hl ppc">#define free(ptr) _test_free(ptr, __FILE__, __LINE__)</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// UNIT_TESTING</span>
<span class="hl ppc"></span>
<span class="hl com">/**</span>
<span class="hl com"> * Создание новой строки в куче. Трюк &quot;sizeof(string_t)&quot; используется, чтобы</span>
<span class="hl com"> * правильно отработать ситуацию, если из-за выравнивания между элементами</span>
<span class="hl com"> * структуры string_t 'sz' и 'data' вдруг появится промежуток.</span>
<span class="hl com"> */</span> 
string_t<span class="hl opt">*</span> <span class="hl kwd">string_new</span><span class="hl opt">(</span><span class="hl kwb">int</span> sz<span class="hl opt">) {</span>
  <span class="hl kwa">return</span> <span class="hl kwd">malloc</span><span class="hl opt">(</span><span class="hl kwa">sizeof</span><span class="hl opt">(</span>string_t<span class="hl opt">) +</span> sz <span class="hl opt">-</span> <span class="hl num">1</span><span class="hl opt">);</span>
<span class="hl opt">}</span>

<span class="hl com">/**</span>
<span class="hl com"> * Удаление строки из кучи.</span>
<span class="hl com"> */</span>
<span class="hl kwb">void</span> <span class="hl kwd">_string_delete</span><span class="hl opt">(</span>string_t<span class="hl opt">*</span> str<span class="hl opt">) {</span>
  <span class="hl kwd">free</span><span class="hl opt">((</span><span class="hl kwb">void</span> <span class="hl opt">*)</span>str<span class="hl opt">);</span>
<span class="hl opt">}</span>

<span class="hl com">/**</span>
<span class="hl com"> * Текущая длина строки.</span>
<span class="hl com"> */</span>
<span class="hl kwb">int</span> <span class="hl kwd">_string_length</span><span class="hl opt">(</span><span class="hl kwb">const</span> string_t<span class="hl opt">*</span> str<span class="hl opt">) {</span>
  <span class="hl kwa">return</span> str<span class="hl opt">-&gt;</span>sz<span class="hl opt">;</span>                                                                                        
<span class="hl opt">}</span>

<span class="hl com">/**</span>
<span class="hl com"> * Изменение длины строки.</span>
<span class="hl com"> */</span>
<span class="hl kwb">int</span> <span class="hl kwd">_string_resize</span><span class="hl opt">(</span>string_t<span class="hl opt">*</span> str<span class="hl opt">,</span> <span class="hl kwb">int</span> sz<span class="hl opt">) {</span>
  <span class="hl kwa">return</span> str<span class="hl opt">-&gt;</span>sz <span class="hl opt">=</span> sz<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl com">/**</span>
<span class="hl com"> * Копирование строки из строки С, завершающейся нулем.</span>
<span class="hl com"> */</span>
string_t<span class="hl opt">*</span> <span class="hl kwd">_string_from_c_str</span><span class="hl opt">(</span>string_t<span class="hl opt">*</span> dst<span class="hl opt">,</span> <span class="hl kwb">const char</span><span class="hl opt">*</span> src<span class="hl opt">) {</span>
  <span class="hl kwb">int</span> sz <span class="hl opt">=</span> <span class="hl kwd">strlen</span><span class="hl opt">(</span>src<span class="hl opt">);</span>
  <span class="hl kwd">memcpy</span><span class="hl opt">(</span>dst<span class="hl opt">-&gt;</span>data<span class="hl opt">,</span> src<span class="hl opt">,</span> sz<span class="hl opt">);</span>
  dst<span class="hl opt">-&gt;</span>sz <span class="hl opt">=</span> sz<span class="hl opt">;</span>
  <span class="hl kwa">return</span> dst<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl com">/**</span>
<span class="hl com"> * Добавление символа в строку.</span>
<span class="hl com"> */</span>
string_t<span class="hl opt">*</span> <span class="hl kwd">_string_append_ch</span><span class="hl opt">(</span>string_t<span class="hl opt">*</span> str<span class="hl opt">,</span> <span class="hl kwb">char</span> ch<span class="hl opt">) {</span>
  str<span class="hl opt">-&gt;</span>data<span class="hl opt">[</span>str<span class="hl opt">-&gt;</span>sz<span class="hl opt">++] =</span> ch<span class="hl opt">;</span>
  <span class="hl kwa">return</span> str<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl com">/**</span>
<span class="hl com"> * Превращение строки в строку С с нулем на конце. Фактически,</span>
<span class="hl com"> * в тело строки добавляется ноль и возвращается указатель на данные.</span>
<span class="hl com"> */</span>
<span class="hl kwb">char</span><span class="hl opt">*</span> <span class="hl kwd">_string_c_str</span><span class="hl opt">(</span>string_t<span class="hl opt">*</span> str<span class="hl opt">) {</span>
  str<span class="hl opt">-&gt;</span>data<span class="hl opt">[</span>str<span class="hl opt">-&gt;</span>sz<span class="hl opt">] =</span> <span class="hl num">0</span><span class="hl opt">;</span>
  <span class="hl kwa">return</span> <span class="hl kwd">string_data</span><span class="hl opt">(</span>str<span class="hl opt">);</span>
<span class="hl opt">}</span>
</pre>

<p>Как вы заметили, в коде есть специальный блок, ограниченный макросом <code>UNIT_TESTING</code>. Ничего не поделаешь, в языке С приходится &ldquo;готовить&rdquo; код к потенциальному тестированию и вставлять фрагменты, позволяющие тестовой среде работать с этим кодом. Этот блок, если задан макрос <code>UNIT_TESTING</code>, переопределяет функции работы с кучей, чтобы можно было перехватывать их вызовы. Подменяющие функции <code>_test_malloc()</code>, <code>_test_calloc()</code> и <code>_test_free()</code> предоставляются библиотекой <code>cmockery</code>.</p>

<p>Теперь файл тестов <code>cstring_unittest.c</code>:</p>

<pre class="hl">
<span class="hl ppc">#include &lt;stdarg.h&gt;</span>
<span class="hl ppc">#include &lt;stddef.h&gt;</span>
<span class="hl ppc">#include &lt;setjmp.h&gt;</span>
<span class="hl ppc">#include &lt;cmockery.h&gt;</span>

<span class="hl ppc">#include</span> <span class="hl pps">&quot;cstring.h&quot;</span><span class="hl ppc"></span>

<span class="hl com">/**</span>
<span class="hl com"> * Тестируем декларацию строки длиной 20 в виде автоматической</span>
<span class="hl com"> * переменной, добавляем в нее два символа, обрезаем строку</span>
<span class="hl com"> * до длины в один байт и проверяем, добавился ли 0 при преобразовании</span>
<span class="hl com"> * в строку С.</span>
<span class="hl com"> */</span>
<span class="hl kwb">void</span> <span class="hl kwd">string_c_str_test</span><span class="hl opt">(</span><span class="hl kwb">void</span> <span class="hl opt">**</span>state<span class="hl opt">) {</span>
  <span class="hl kwd">decl_string_t</span><span class="hl opt">(</span>a<span class="hl opt">,</span> <span class="hl num">20</span><span class="hl opt">);</span>
  a<span class="hl opt">.</span>data<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">] =</span> <span class="hl str">'a'</span><span class="hl opt">;</span>
  a<span class="hl opt">.</span>data<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">] =</span> <span class="hl str">'b'</span><span class="hl opt">;</span>
  a<span class="hl opt">.</span>sz <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">;</span>
  <span class="hl kwd">assert_memory_equal</span><span class="hl opt">(</span><span class="hl str">&quot;a\0&quot;</span><span class="hl opt">,</span> <span class="hl kwd">string_c_str</span><span class="hl opt">(&amp;</span>a<span class="hl opt">),</span> <span class="hl num">2</span><span class="hl opt">);</span>
<span class="hl opt">}</span>

<span class="hl com">/**</span>
<span class="hl com"> * Тестируем изменение длины строки.</span>
<span class="hl com"> */</span>
<span class="hl kwb">void</span> <span class="hl kwd">string_resize_test</span><span class="hl opt">(</span><span class="hl kwb">void</span> <span class="hl opt">**</span>state<span class="hl opt">) {</span>
  <span class="hl kwd">decl_string_t</span><span class="hl opt">(</span>a<span class="hl opt">,</span> <span class="hl num">20</span><span class="hl opt">);</span>
  a<span class="hl opt">.</span>sz <span class="hl opt">=</span> <span class="hl num">2</span><span class="hl opt">;</span>
  <span class="hl kwd">string_resize</span><span class="hl opt">(&amp;</span>a<span class="hl opt">,</span> <span class="hl num">1</span><span class="hl opt">);</span>
  <span class="hl kwd">assert_int_equal</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">,</span> <span class="hl kwd">string_length</span><span class="hl opt">(&amp;</span>a<span class="hl opt">));</span>
<span class="hl opt">}</span>

<span class="hl com">/**</span>
<span class="hl com"> * Тестируем добавление символа путем сравнения со строками С</span>
<span class="hl com"> */</span>
<span class="hl kwb">void</span> <span class="hl kwd">string_append_ch_test</span><span class="hl opt">(</span><span class="hl kwb">void</span> <span class="hl opt">**</span>state<span class="hl opt">) {</span>
  <span class="hl kwd">decl_string_t</span><span class="hl opt">(</span>a<span class="hl opt">,</span> <span class="hl num">20</span><span class="hl opt">);</span>
  <span class="hl kwd">assert_string_equal</span><span class="hl opt">(</span><span class="hl str">&quot;&quot;</span><span class="hl opt">,</span> <span class="hl kwd">string_c_str</span><span class="hl opt">(&amp;</span>a<span class="hl opt">));</span>
  <span class="hl kwd">assert_string_equal</span><span class="hl opt">(</span><span class="hl str">&quot;a&quot;</span><span class="hl opt">,</span> <span class="hl kwd">string_c_str</span><span class="hl opt">(</span><span class="hl kwd">string_append_ch</span><span class="hl opt">(&amp;</span>a<span class="hl opt">,</span> <span class="hl str">'a'</span><span class="hl opt">)));</span>
  <span class="hl kwd">assert_string_equal</span><span class="hl opt">(</span><span class="hl str">&quot;ab&quot;</span><span class="hl opt">,</span> <span class="hl kwd">string_c_str</span><span class="hl opt">(</span><span class="hl kwd">string_append_ch</span><span class="hl opt">(&amp;</span>a<span class="hl opt">,</span> <span class="hl str">'b'</span><span class="hl opt">)));</span>
<span class="hl opt">}</span>

<span class="hl com">/**</span>
<span class="hl com"> * Тестируем декларацию строки в виде автоматической переменной.</span>
<span class="hl com"> * Длина строки сразу после декларации должна быть нулевой.</span>
<span class="hl com"> */</span>
<span class="hl kwb">void</span> <span class="hl kwd">string_declare_test</span><span class="hl opt">(</span><span class="hl kwb">void</span> <span class="hl opt">**</span>state<span class="hl opt">) {</span>
  <span class="hl kwd">decl_string_t</span><span class="hl opt">(</span>a<span class="hl opt">,</span> <span class="hl num">20</span><span class="hl opt">);</span>
  <span class="hl kwd">assert_int_equal</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">,</span> <span class="hl kwd">string_length</span><span class="hl opt">(&amp;</span>a<span class="hl opt">));</span>
<span class="hl opt">}</span>

<span class="hl com">/**</span>
<span class="hl com"> * Тестируем размещение новой строки в куче и ее удаление из нее.</span>
<span class="hl com"> */</span>
<span class="hl kwb">void</span> <span class="hl kwd">string_heap_allocation_test</span><span class="hl opt">(</span><span class="hl kwb">void</span> <span class="hl opt">**</span>state<span class="hl opt">) {</span>
  string_t<span class="hl opt">*</span> a <span class="hl opt">=</span> <span class="hl kwd">string_new</span><span class="hl opt">(</span><span class="hl num">20</span><span class="hl opt">);</span>
  <span class="hl kwd">string_delete</span><span class="hl opt">(</span>a<span class="hl opt">);</span>
<span class="hl opt">}</span>

<span class="hl com">/**</span>
<span class="hl com"> * Тестируем копирование строки из строки С с нулем на конце.</span>
<span class="hl com"> */</span>
<span class="hl kwb">void</span> <span class="hl kwd">string_from_c_str_test</span><span class="hl opt">(</span><span class="hl kwb">void</span> <span class="hl opt">**</span>state<span class="hl opt">) {</span>
  string_t<span class="hl opt">*</span> a <span class="hl opt">=</span> <span class="hl kwd">string_new</span><span class="hl opt">(</span><span class="hl num">8</span><span class="hl opt">);</span>
  <span class="hl kwd">string_from_c_str</span><span class="hl opt">(</span>a<span class="hl opt">,</span> <span class="hl str">&quot;12345678&quot;</span><span class="hl opt">);</span>
  <span class="hl kwd">assert_int_equal</span><span class="hl opt">(</span><span class="hl num">8</span><span class="hl opt">,</span> <span class="hl kwd">string_length</span><span class="hl opt">(</span>a<span class="hl opt">));</span>
  <span class="hl kwd">string_delete</span><span class="hl opt">(</span>a<span class="hl opt">);</span>
<span class="hl opt">}</span>

<span class="hl com">/**</span>
<span class="hl com"> * Создаем список тестов и запускаем их.</span>
<span class="hl com"> */</span>
<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">(</span><span class="hl kwb">int</span> argc<span class="hl opt">,</span> <span class="hl kwb">char</span><span class="hl opt">*</span> argv<span class="hl opt">[]) {</span>
  <span class="hl kwb">const</span> UnitTest tests<span class="hl opt">[] = {</span>
    <span class="hl kwd">unit_test</span><span class="hl opt">(</span>string_declare_test<span class="hl opt">),</span>
    <span class="hl kwd">unit_test</span><span class="hl opt">(</span>string_c_str_test<span class="hl opt">),</span>
    <span class="hl kwd">unit_test</span><span class="hl opt">(</span>string_append_ch_test<span class="hl opt">),</span>
    <span class="hl kwd">unit_test</span><span class="hl opt">(</span>string_heap_allocation_test<span class="hl opt">),</span>
    <span class="hl kwd">unit_test</span><span class="hl opt">(</span>string_from_c_str_test<span class="hl opt">),</span>
    <span class="hl kwd">unit_test</span><span class="hl opt">(</span>string_resize_test<span class="hl opt">),</span>
  <span class="hl opt">};</span>
  <span class="hl kwa">return</span> <span class="hl kwd">run_tests</span><span class="hl opt">(</span>tests<span class="hl opt">);</span>
<span class="hl opt">}</span>
</pre>

<p>Схема очень похожа на любое другое <a href="http://en.wikipedia.org/wiki/Unit_testing">xUnit</a> тестирование: каждый тест проверяет какой-то один функциональный элемент, тесты объединяются в группы и запускаются автоматически все вместе. Правда, из-за ограничений языка С каждый тест приходится вручную добавлять в список запуска, увы.</p>

<p>Как я уже сказал, для компиляции потребуются файлы <code>cmockery.c</code> и <code>cmockery.h</code> (см. выше). Эти файлы можно положить в текущий каталог.</p>

<p>Компилируем в Visual Studio:</p>

<pre><code>cl /DUNIT_TESTING /I. cstring_unittest.c cstring.c cmockery.c
</code></pre>

<p>Если все скомпилировалось нормально, то запускаем файл <code>cstring_unittest</code>:</p>

<pre><code>string_declare_test: Starting test
string_declare_test: Test completed successfully.
string_c_str_test: Starting test
string_c_str_test: Test completed successfully.
string_append_ch_test: Starting test
string_append_ch_test: Test completed successfully.
string_heap_allocation_test: Starting test
string_heap_allocation_test: Test completed successfully.
string_from_c_str_test: Starting test
string_from_c_str_test: Test completed successfully.
string_resize_test: Starting test
string_resize_test: Test completed successfully.
All 6 tests passed
</code></pre>

<p>Все тесты отработали правильно.</p>

<p>Но неинтересно, когда все работает. Внесем в тест библиотеки &ldquo;случайные ошибки&rdquo;. Каждую из них можно спокойно допустить непреднамеренно. Строки с ошибками я пометил комментариями со словом &ldquo;ОШИБКА (!)&rdquo;. Посмотрим, как <code>cmockery</code> справится с этим.</p>

<p>Файл <code>cstring.c</code> с &ldquo;ошибками&rdquo;:</p>

<pre class="hl">
<span class="hl ppc">#include &lt;stdlib.h&gt;</span>

<span class="hl ppc">#include</span> <span class="hl pps">&quot;cstring.h&quot;</span><span class="hl ppc"></span>

<span class="hl com">/**</span>
<span class="hl com"> * Подготовительная площадка для тестирования.</span>
<span class="hl com"> * Если задан макрос UNIT_TESTING, то функции работы с кучей подменяются</span>
<span class="hl com"> * на тестовые.</span>
<span class="hl com"> */</span>
<span class="hl ppc">#if UNIT_TESTING</span>
<span class="hl kwc">extern</span> <span class="hl kwb">void</span><span class="hl opt">*</span> <span class="hl kwd">_test_malloc</span><span class="hl opt">(</span><span class="hl kwb">const size_t</span> size<span class="hl opt">,</span> <span class="hl kwb">const char</span><span class="hl opt">*</span> file<span class="hl opt">,</span> <span class="hl kwb">const int</span> line<span class="hl opt">);</span>
<span class="hl kwc">extern</span> <span class="hl kwb">void</span><span class="hl opt">*</span> <span class="hl kwd">_test_calloc</span><span class="hl opt">(</span><span class="hl kwb">const size_t</span> number_of_elements<span class="hl opt">,</span> <span class="hl kwb">const size_t</span> size<span class="hl opt">,</span>
                          <span class="hl kwb">const char</span><span class="hl opt">*</span> file<span class="hl opt">,</span> <span class="hl kwb">const int</span> line<span class="hl opt">);</span>
<span class="hl kwc">extern</span> <span class="hl kwb">void</span> <span class="hl kwd">_test_free</span><span class="hl opt">(</span><span class="hl kwb">void</span><span class="hl opt">*</span> <span class="hl kwb">const</span> ptr<span class="hl opt">,</span> <span class="hl kwb">const char</span><span class="hl opt">*</span> file<span class="hl opt">,</span> <span class="hl kwb">const int</span> line<span class="hl opt">);</span>

<span class="hl ppc">#define malloc(size) _test_malloc(size, __FILE__, __LINE__)</span>
<span class="hl ppc">#define calloc(num, size) _test_calloc(num, size, __FILE__, __LINE__)</span>
<span class="hl ppc">#define free(ptr) _test_free(ptr, __FILE__, __LINE__)</span>
<span class="hl ppc">#endif</span> <span class="hl slc">// UNIT_TESTING</span>
<span class="hl ppc"></span>
<span class="hl com">/**</span>
<span class="hl com"> * Создание новой строки в куче. Трюк &quot;sizeof(string_t)&quot; используется, чтобы</span>
<span class="hl com"> * правильно отработать ситуацию, если из-за выравнивания между элементами</span>
<span class="hl com"> * структуры string_t 'sz' и 'data' вдруг появится промежуток.</span>
<span class="hl com"> */</span> 
string_t<span class="hl opt">*</span> <span class="hl kwd">string_new</span><span class="hl opt">(</span><span class="hl kwb">int</span> sz<span class="hl opt">) {</span>
  <span class="hl kwa">return</span> <span class="hl kwd">malloc</span><span class="hl opt">(</span><span class="hl kwa">sizeof</span><span class="hl opt">(</span>string_t<span class="hl opt">) +</span> <span class="hl num">1</span> <span class="hl opt">-</span> <span class="hl num">1</span><span class="hl opt">);</span> <span class="hl slc">// (ОШИБКА!) &quot;Неверная&quot; длина.</span>
<span class="hl opt">}</span>

<span class="hl com">/**</span>
<span class="hl com"> * Удаление строки из кучи.</span>
<span class="hl com"> */</span>
<span class="hl kwb">void</span> <span class="hl kwd">_string_delete</span><span class="hl opt">(</span>string_t<span class="hl opt">*</span> str<span class="hl opt">) {</span>
  <span class="hl slc">// (ОШИБКА!) &quot;Забыли&quot; вызвать free().</span>
<span class="hl opt">}</span>

<span class="hl com">/**</span>
<span class="hl com"> * Текущая длина строки.</span>
<span class="hl com"> */</span>
<span class="hl kwb">int</span> <span class="hl kwd">_string_length</span><span class="hl opt">(</span><span class="hl kwb">const</span> string_t<span class="hl opt">*</span> str<span class="hl opt">) {</span>
  <span class="hl kwa">return</span> str<span class="hl opt">-&gt;</span>sz<span class="hl opt">;</span>                                                                                        
<span class="hl opt">}</span>

<span class="hl com">/**</span>
<span class="hl com"> * Изменение длины строки.</span>
<span class="hl com"> */</span>
<span class="hl kwb">int</span> <span class="hl kwd">_string_resize</span><span class="hl opt">(</span>string_t<span class="hl opt">*</span> str<span class="hl opt">,</span> <span class="hl kwb">int</span> sz<span class="hl opt">) {</span>
  <span class="hl kwa">return</span> str<span class="hl opt">-&gt;</span>sz<span class="hl opt">;</span>  <span class="hl slc">// (ОШИБКА!) &quot;Забыли&quot; уменьшить длину строки.</span>
<span class="hl opt">}</span>

<span class="hl com">/**</span>
<span class="hl com"> * Копирование строки из строки С, завершающейся нулем.</span>
<span class="hl com"> */</span>
string_t<span class="hl opt">*</span> <span class="hl kwd">_string_from_c_str</span><span class="hl opt">(</span>string_t<span class="hl opt">*</span> dst<span class="hl opt">,</span> <span class="hl kwb">const char</span><span class="hl opt">*</span> src<span class="hl opt">) {</span>
  <span class="hl kwb">int</span> sz <span class="hl opt">=</span> <span class="hl kwd">strlen</span><span class="hl opt">(</span>src<span class="hl opt">);</span>
  <span class="hl kwd">memcpy</span><span class="hl opt">(</span>dst<span class="hl opt">-&gt;</span>data<span class="hl opt">,</span> src<span class="hl opt">,</span> sz<span class="hl opt">);</span>
  <span class="hl slc">// (ОШИБКА!) &quot;Забыли&quot; присвоить длине новое значение.</span>
  <span class="hl kwa">return</span> dst<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl com">/**</span>
<span class="hl com"> * Добавление символа в строку.</span>
<span class="hl com"> */</span>
string_t<span class="hl opt">*</span> <span class="hl kwd">_string_append_ch</span><span class="hl opt">(</span>string_t<span class="hl opt">*</span> str<span class="hl opt">,</span> <span class="hl kwb">char</span> ch<span class="hl opt">) {</span>
  str<span class="hl opt">-&gt;</span>data<span class="hl opt">[</span>str<span class="hl opt">-&gt;</span>sz<span class="hl opt">] =</span> ch<span class="hl opt">;</span> <span class="hl slc">// (ОШИБКА!) &quot;Забыли&quot; увеличить длину.</span>
  <span class="hl kwa">return</span> str<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl com">/**</span>
<span class="hl com"> * Превращение строки в строку С с нулем на конце. Фактически,</span>
<span class="hl com"> * в тело строки добавляется ноль и возвращается указатель на данные.</span>
<span class="hl com"> */</span>
<span class="hl kwb">char</span><span class="hl opt">*</span> <span class="hl kwd">_string_c_str</span><span class="hl opt">(</span>string_t<span class="hl opt">*</span> str<span class="hl opt">) {</span>
  <span class="hl slc">// (ОШИБКА!) &quot;Забыли&quot; добавить 0 в конец.</span>
  <span class="hl kwa">return</span> <span class="hl kwd">string_data</span><span class="hl opt">(</span>str<span class="hl opt">);</span>
<span class="hl opt">}</span>
</pre>

<p>Компилируем и запускаем:</p>

<pre><code>string_declare_test: Starting test
string_declare_test: Test completed successfully.
string_c_str_test: Starting test
difference at offset 1 0x00 0x62
1 bytes of 0x0040f014 and 0x0012fe7c differ
ERROR: cstring_unittest.c:19 Failure!
string_c_str_test: Test failed.
string_append_ch_test: Starting test
&quot;ab&quot; != &quot;b&quot;
ERROR: cstring_unittest.c:39 Failure!
string_append_ch_test: Test failed.
string_heap_allocation_test: Starting test
Blocks allocated...
  0x00326ee0 : cstring.c:27
ERROR: string_heap_allocation_test leaked 1 block(s)
string_heap_allocation_test: Test failed.
string_from_c_str_test: Starting test
Blocks allocated...
  0x00326ee0 : cstring.c:27
Guard block of 0x00326f18 size=8 allocated by cstring.c:27 at 0x00326f20 is corrupt
ERROR: cmockery.c:1379 Failure!
string_from_c_str_test: Test failed.
string_resize_test: Starting test
0x1 != 0x2
ERROR: cstring_unittest.c:29 Failure!
string_resize_test: Test failed.
5 out of 6 tests failed!
    string_c_str_test
    string_append_ch_test
    string_heap_allocation_test
    string_from_c_str_test
    string_resize_test
Blocks allocated...
  0x00326ee0 : cstring.c:27
Guard block of 0x00326f18 size=8 allocated by cstring.c:27 at 0x00326f20 is corrupt
ERROR: cmockery.c:1379 Failure!
</code></pre>

<p>Бам! 5 из 6 тестов сломаны. Проанализируем полученное.</p>

<p>Тест <code>string_c_str_test</code> выявил, что функция <code>string_c_str</code> не добавила 0 в конец строки, хотя должна была:</p>

<pre><code>string_c_str_test: Starting test
difference at offset 1 0x00 0x62
1 bytes of 0x0040f014 and 0x0012fe7c differ
ERROR: cstring_unittest.c:19 Failure!
string_c_str_test: Test failed.
</code></pre>

<p>Тест <code>string_append_ch_test</code> выявил, что функция добавления символа в конец строки не работает:</p>

<pre><code>string_append_ch_test: Starting test
&quot;ab&quot; != &quot;b&quot;
ERROR: cstring_unittest.c:39 Failure!
string_append_ch_test: Test failed.
</code></pre>

<p>Тест <code>string_heap_allocation_test</code> выявил, что у нас имеется неосвобожденный блок памяти (утечка?). Конечно, мы же &ldquo;забыли&rdquo; освободить память в функции <code>string_delete()</code>:</p>

<pre><code>string_heap_allocation_test: Starting test
Blocks allocated...
  0x00326ee0 : cstring.c:27
ERROR: string_heap_allocation_test leaked 1 block(s)
string_heap_allocation_test: Test failed.
</code></pre>

<p>Тест <code>string_from_c_str_test</code> выявил, что мы &ldquo;вылезли&rdquo; за границы выделенного куска памяти. Мы записали что-то мимо. Это болезненная ошибка. Конечно, <code>cmockery</code> не всегда может находить такие ляпы. Например, если переменная выделена с стеке, а не в куче, то проблема не вскроется. Тут уже помогут только динамические отладчики типа <a href="http://valgrind.org/">valgrind</a>:</p>

<pre><code>string_from_c_str_test: Starting test
Blocks allocated...
  0x00326ee0 : cstring.c:27
Guard block of 0x00326f18 size=8 allocated by cstring.c:27 at 0x00326f20 is corrupt
ERROR: cmockery.c:1379 Failure!
string_from_c_str_test: Test failed.
</code></pre>

<p>Тест <code>string_resize_test</code> показал, что функция изменения размера строки не работает как положено:</p>

<pre><code>string_resize_test: Starting test
0x1 != 0x2
ERROR: cstring_unittest.c:29 Failure!
string_resize_test: Test failed.
</code></pre>

<p>В целом, очень неплохие результаты.</p>

<p>Теперь представьте, что вы решили переписать реализацию библиотеки под новый процессор, чтобы работало в десять раз быстрее. Но как проверить результат? Элементарно. Запустите старые тесты. Если они работают, то по крайней мере с большой вероятностью вы не сломали старую функциональность. И, кстати, чем более тщательно написаны тесты, тем более ценны они. Чем более критична какая часть системы для стабильности системы в целом (например, библиотека строк или каких-то базовых контейнеров), тем более тщательно они должны быть покрыты тестами.</p>

<p>Конечно, уровень комфорта при написании тестов на С и их отладке очень далек даже от С++, но это не может быть оправданием для отказа от тестирования. Честно могу сказать, часто результатом работы &ldquo;сломанного&rdquo; теста в С, который неверно работает с памятью, например, может является просто зависание, а не красивый отчет, что тест &ldquo;не работает&rdquo;. Но даже такой &ldquo;знак&rdquo; очень важен и дает понять, что что-то сломано. Пусть лучше повиснет тест, нежели готовый продукт у заказчика.</p>

<p>Под занавес приведу список основных функций-проверок (<code>assert</code>-фукнции), которые доступны в <code>cmockery</code>:</p>

<ul>
<li><code>assert_true()</code>, <code>assert_false()</code> — проверка булевых флагов</li>
<li><code>assert_int_equal()</code>, <code>assert_int_not_equal()</code> — сравнение для типа <code>int</code></li>
<li><code>assert_string_equal()</code>, <code>assert_string_not_equal()</code> — сравнение для типа <code>char*</code> (для С-строк, заканчивающихся нулем)</li>
<li><code>assert_memory_equal()</code>, <code>assert_memory_not_equal()</code> — сравнение кусков памяти</li>
<li><code>assert_in_range()</code>, <code>assert_not_in_range()</code> — проверка нахождения числа в указанном интервале</li>
<li><code>assert_in_set()</code>, <code>assert_not_in_set()</code> — проверка нахождения строки <code>(char*)</code> среди заданного набора строк</li>
<li><code>fail()</code> — безусловное завершения теста с ошибкой</li>
</ul>

<p><strong>Вывод</strong></p>

<p>Unit-тестирование в С порой сопряжено с трудностями, но оно возможно. И нет причин от него отказываться.</p>

</div>

<hr />


  <a href="http://easy-coding.blogspot.com/2009/03/unit.html"><small>Оригинальный пост</small></a>


<h1>Комментарии</h1>

<div id="disqus_thread"></div>

<script type="text/javascript">
  var disqus_shortname = 'easy-coding';
  var disqus_developer = 0;
  var disqus_identifier = 'http://easy-coding.blogspot.com/2009/03/unit.html';
  var disqus_url = 'http://easy-coding.blogspot.com/2009/03/unit.html';
  var disqus_script = 'embed.js';
  (function () {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  }());
</script>


  </div>

  <div class="footer">
    <div class="contact">
      &copy; 2012
      <a href="mailto:alexander@demin.ws">Александр Дëмин</a> |
      <a href="/atom.xml" rel="subscribe-rss" title="Подписаться через RSS">RSS</a>
    </div>
  </div>

</div>

</body>
</html>
